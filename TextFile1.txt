=PROJEYE AÝT NOTLAR=

*Entities projemiz bizler için veritabanýna gidecek ve bir tablo oluþturacak deðerleri barýndýracaktýr.
*DTU veritabaný objelerini parçaladýðý ve onlara küçük deðerler verdiði objelerdir, sýnýflardýr.
*Data proje kýsmýmýz veritabaný ile ilgili iþleri halledecektir. Örnek olarak veritabanýna baðlanýlmasý bir verinin eklenmesi, düzenlenmesi veya silinmesi gibi iþlemleri gerçekleþtirecektir.
*Services katmaný veriyi servis ettiðimiz ve servis etmek için hazýrladýðýmýz katmandýr. Ýþ mantýðý yürütülür. MEsela veritabanýndan gelen verilerin front end kýsmýna gönderilmeden önce hazýrlanmasý ve belirli iþlemlerden geçmesi gereken katmandýr.
*Mvc katmaný ise front-end katmanýdýr.

*EntityBase sýnýfýný ve IEntity arayüzünü oluþturalým. Veritabanýna yazýlacak tablolarda ortak bulunmasýný istediðimiz tablolarý bu base classta toplayacaðýz. IEntity ile veritabanýna gidecek sýnýflarla ilgili karýþýklýklarý önleyeceðiz.
*Entities adlý bir klasör oluþturuyoruz. Ýçine de abstract klasörü ekliyoruz. EntityBase sýnýfýmýzý buraya koyacaðýz.
*içerisine id, createddate, modifieddate, delete, active, createdbyname, modifiedbyname proplarýný ekledik.
*Entities içine concrete klasörü açtýk. Somut nesnelerimizi ekleyeceðiz... veritabaný nesnesi vs.

*Ýlk veritabaný nesnesimizi oluþturalým. (Category).
*Category'nin içerisinde bulunmasý gereken bölümleri ekleyelim. Örn = Name, Description, Articles gibi...

*Article sýnýfýmýzý oluþturalým.
*Article kýsmýnda bulunmasý gereken konu baþlýklarýný ekleyelim. Örn= category id, category'ye ulaþmamýzý saðlayan property, user id, user, baþlýk, içerik, thumbnail, yorum sayýsý, date, yorum sayýsý, seo bilgileri gibi...
*SEO: Arama motoru optimizasyonu demektir. Web sitelerini arama motorlarýnýn daha rahat bir þekilde anlayabilmesine "taramasýna" olanak saðlayacak þekilde arama motorlarýnýn kriterlerine uygun hale getirilerek "web sitesinin optimize edilmesi" hedeflenen anahatar kelimelere ait arama motoru aramalarýnda yükseltilmesidir.
*user ve role sýnýflarýmýzý oluþturduk.

*Comment nesnesini oluþturalým ve alanlarýný ekleyelim.
*Article ve comment birbirlerini refere ettikleri için bire çok iliþkiye sahip oldular.

*Shared üzerinde IEntityRepository<T> arayüzümüzü oluþturuyoruz. Tüm DAL classlarýmýzda ortak kullanacaðýmýz metodlarý bu repository içerisine ekleyeceðiz.
*Get(), GetAll(), Add(), Update(), Delete(), Any(), Count() gibi metodlarý IEntityRepository<T> içerisinde kullanarak kod tekrarýndan kaçýnmýþ olacaðýz.
*Shared projemize eklememizin sebebi eðer baþka projelerde de kullanmak istiyorsan bu shared projesinden kolaylýkla çekebiliriz.
*EfEntityRepository<T> sýnýfýmýzý oluþturup IEntityRepository<T> sýnýfýmýz ile implemente edelim ve EntityFramework kullanarak da bu metotlarýmýzýn içeriðini dolduralým.

*Data projesi üzerinde IEntityRepository<T> interfaceimizin implementasyonunu yapalým. Bu sayede entitylerimize ait tüm repository interfacelerinin daha öncesinde yazmýþ olduðumuz metotlara sahip olmalarýný saðlýyoruz.
*Classlarýn somut ve soyut olmasý zorunludur. Örneðin IArticleRepository --> ArticleRepository gibi...
*Data kýsmýna referans ekliyoruz. Dataya Entities ve Shared'ý referans olarak ekliyoruz.
*Generic repositorymizi entity repositorylere implement etmiþ olduk

*Concrete yani somut classlar kodlayacaz. Abstract sýnýfýmýzýn içindeki classlarý implement edecek classlar oluþturacaðýz.
*Data katmanýmýz üzerinde ProgrammersBlogContext sýnýfýný oluþturup, projemiz boyunca veritabaný iþlemlerimiz için kullanacaðýmýz DbContext nesnemiz olacaktýr.
*Data katmanýmýza entityframeworkcore, entityframeworkcore.sqlserver, entityframeworkcore.design ekleyelim.

*Codefirst yaklaþýmýný kullanacaðýz ve migrationslarla database update edeceðiz.
*Mappings adlý bir klasör oluþturduk. Fluent Api kullanarak veritabanýna girecek nesnelerimizin ayarlarýný yaptýðýmýz yerdir.
*DbSetlerimizi oluþturalým.

*Veritabanýna gidecek article nesnemizin mapping iþlemlerini yapacaðýz.
*Mapping iþlemleri bizim veritabanýna gidecek iþlemlerimizin ayarlarýný ve özelliklerini belirlediðimiz bölümdür. Örnek olarak Article nesnemizin id alaný var mý? primary key mi? gibi sorularýn cevaplarýný belirlediðimiz bölümdür.

*Articlemap iþlemleri tamamlandý. Veritabanýnda olmasý gereken özellikler her bir alan için ayrý ayrý belirtildi. 
*Categorymap iþlemleri tamamlandý. Veritabanýnda olmasý gereken özellikler her bir alan için ayrý ayrý belirtildi.
*Commentmap iþlemleri tamamlandý. Veritabanýnda olmasý gereken özellikler her bir alan için ayrý ayrý belirtildi.
*Rolemap iþlemleri tamamlandý. Veritabanýnda olmasý gereken özellikler her bir alan için ayrý ayrý belirtildi.
*Usermap iþlemleri tamamlandý. Veritabanýnda olmasý gereken özellikler her bir alan için ayrý ayrý belirtildi.
*Tüm mapping iþlemlerini DbContext içerisinde bir configuration sýnýfý olarak çaðýracaðýz.Yani veritabanýna giderken ayarlarýný bu sýnýflardan al demiþ olacaðýz.

*Unit Of Work tasarým desenini uygulamak için IUnitOfWork arayüzünü oluþturuyoruz.
*Unit Of Work tasarým desenini kullanarak tüm repositoryleri tek bir yerden yönetebiliriz. Yani servis katmanýnda yeni bir kllanýcý eklerken role ve user a ihtiyaç duyarýz. unitofwork ile bu sýnýf üzerinden ikisine de eriþebiliriz.
*Bizlere transaction yapýsý tutar. Transaction veritabýna gönderdiðimiz verilerin doðrulanmasý ve yönetilmesidir.
*